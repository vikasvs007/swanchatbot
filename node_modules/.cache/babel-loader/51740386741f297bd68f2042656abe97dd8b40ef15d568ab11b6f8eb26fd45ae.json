{"ast":null,"code":"import { capturePointer, isPrimaryPointer } from 'motion-dom';\nimport { secondsToMilliseconds, millisecondsToSeconds } from 'motion-utils';\nimport { addPointerEvent } from '../../events/add-pointer-event.mjs';\nimport { extractEventInfo } from '../../events/event-info.mjs';\nimport { distance2D } from '../../utils/distance.mjs';\nimport { pipe } from '../../utils/pipe.mjs';\nimport { frame, cancelFrame, frameData } from '../../frameloop/frame.mjs';\n\n/**\n * @internal\n */\nclass PanSession {\n  constructor(event, handlers, {\n    transformPagePoint,\n    dragSnapToOrigin = false\n  } = {}) {\n    /**\n     * @internal\n     */\n    this.startEvent = null;\n    /**\n     * @internal\n     */\n    this.lastMoveEvent = null;\n    /**\n     * @internal\n     */\n    this.lastMoveEventInfo = null;\n    /**\n     * @internal\n     */\n    this.handlers = {};\n    this.updatePoint = () => {\n      if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return;\n      const info = getPanInfo(this.lastMoveEventInfo, this.history);\n      const isPanStarted = this.startEvent !== null;\n      // Only start panning if the offset is larger than 3 pixels. If we make it\n      // any larger than this we'll want to reset the pointer history\n      // on the first update to avoid visual snapping to the cursoe.\n      const isDistancePastThreshold = distance2D(info.offset, {\n        x: 0,\n        y: 0\n      }) >= 3;\n      if (!isPanStarted && !isDistancePastThreshold) return;\n      const {\n        point\n      } = info;\n      const {\n        timestamp\n      } = frameData;\n      this.history.push({\n        ...point,\n        timestamp\n      });\n      const {\n        onStart,\n        onMove\n      } = this.handlers;\n      if (!isPanStarted) {\n        onStart && onStart(this.lastMoveEvent, info);\n        this.startEvent = this.lastMoveEvent;\n      }\n      onMove && onMove(this.lastMoveEvent, info);\n    };\n    this.handlePointerMove = (event, info) => {\n      this.index = getElementIndex(event.currentTarget);\n      if (event.target instanceof Element && event.target.hasPointerCapture && event.pointerId !== undefined) {\n        try {\n          if (!event.target.hasPointerCapture(event.pointerId)) {\n            return;\n          }\n        } catch (e) {}\n      }\n      this.lastMoveEvent = event;\n      this.lastMoveEventInfo = transformPoint(info, this.transformPagePoint);\n      // Throttle mouse move event to once per frame\n      frame.update(this.updatePoint, true);\n    };\n    this.handlePointerUp = (event, info) => {\n      capturePointer(event, \"release\");\n      this.end();\n      const {\n        onEnd,\n        onSessionEnd,\n        resumeAnimation\n      } = this.handlers;\n      if (this.dragSnapToOrigin) resumeAnimation && resumeAnimation();\n      if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return;\n      const panInfo = getPanInfo(event.type === \"pointercancel\" || event.type === \"lostpointercapture\" ? this.lastMoveEventInfo : transformPoint(info, this.transformPagePoint), this.history);\n      if (this.startEvent && onEnd) {\n        onEnd(event, panInfo);\n      }\n      onSessionEnd && onSessionEnd(event, panInfo);\n    };\n    // If we have more than one touch, don't start detecting this gesture\n    if (!isPrimaryPointer(event)) return;\n    this.dragSnapToOrigin = dragSnapToOrigin;\n    this.handlers = handlers;\n    this.transformPagePoint = transformPagePoint;\n    const info = extractEventInfo(event);\n    const initialInfo = transformPoint(info, this.transformPagePoint);\n    const {\n      point\n    } = initialInfo;\n    const {\n      timestamp\n    } = frameData;\n    this.history = [{\n      ...point,\n      timestamp\n    }];\n    const {\n      onSessionStart\n    } = handlers;\n    onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));\n    capturePointer(event, \"set\");\n    this.removeListeners = pipe(addPointerEvent(event.currentTarget, \"pointermove\", this.handlePointerMove), addPointerEvent(event.currentTarget, \"pointerup\", this.handlePointerUp), addPointerEvent(event.currentTarget, \"pointercancel\", this.handlePointerUp), addPointerEvent(event.currentTarget, \"lostpointercapture\", (lostPointerEvent, lostPointerInfo) => {\n      const index = getElementIndex(lostPointerEvent.currentTarget);\n      /**\n       * If the pointer has lost capture because it's moved in the DOM\n       * then we need to re-capture it.\n       */\n      if (index !== this.index) {\n        capturePointer(lostPointerEvent, \"set\");\n      } else {\n        this.handlePointerUp(lostPointerEvent, lostPointerInfo);\n      }\n    }));\n  }\n  updateHandlers(handlers) {\n    this.handlers = handlers;\n  }\n  end() {\n    this.removeListeners && this.removeListeners();\n    cancelFrame(this.updatePoint);\n  }\n}\nfunction transformPoint(info, transformPagePoint) {\n  return transformPagePoint ? {\n    point: transformPagePoint(info.point)\n  } : info;\n}\nfunction subtractPoint(a, b) {\n  return {\n    x: a.x - b.x,\n    y: a.y - b.y\n  };\n}\nfunction getPanInfo({\n  point\n}, history) {\n  return {\n    point,\n    delta: subtractPoint(point, lastDevicePoint(history)),\n    offset: subtractPoint(point, startDevicePoint(history)),\n    velocity: getVelocity(history, 0.1)\n  };\n}\nfunction startDevicePoint(history) {\n  return history[0];\n}\nfunction lastDevicePoint(history) {\n  return history[history.length - 1];\n}\nfunction getVelocity(history, timeDelta) {\n  if (history.length < 2) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n  let i = history.length - 1;\n  let timestampedPoint = null;\n  const lastPoint = lastDevicePoint(history);\n  while (i >= 0) {\n    timestampedPoint = history[i];\n    if (lastPoint.timestamp - timestampedPoint.timestamp > secondsToMilliseconds(timeDelta)) {\n      break;\n    }\n    i--;\n  }\n  if (!timestampedPoint) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n  const time = millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp);\n  if (time === 0) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n  const currentVelocity = {\n    x: (lastPoint.x - timestampedPoint.x) / time,\n    y: (lastPoint.y - timestampedPoint.y) / time\n  };\n  if (currentVelocity.x === Infinity) {\n    currentVelocity.x = 0;\n  }\n  if (currentVelocity.y === Infinity) {\n    currentVelocity.y = 0;\n  }\n  return currentVelocity;\n}\nfunction getElementIndex(element) {\n  if (!element.parentNode) return -1;\n  return Array.from(element.parentNode.children).indexOf(element);\n}\nexport { PanSession };","map":{"version":3,"names":["capturePointer","isPrimaryPointer","secondsToMilliseconds","millisecondsToSeconds","addPointerEvent","extractEventInfo","distance2D","pipe","frame","cancelFrame","frameData","PanSession","constructor","event","handlers","transformPagePoint","dragSnapToOrigin","startEvent","lastMoveEvent","lastMoveEventInfo","updatePoint","info","getPanInfo","history","isPanStarted","isDistancePastThreshold","offset","x","y","point","timestamp","push","onStart","onMove","handlePointerMove","index","getElementIndex","currentTarget","target","Element","hasPointerCapture","pointerId","undefined","e","transformPoint","update","handlePointerUp","end","onEnd","onSessionEnd","resumeAnimation","panInfo","type","initialInfo","onSessionStart","removeListeners","lostPointerEvent","lostPointerInfo","updateHandlers","subtractPoint","a","b","delta","lastDevicePoint","startDevicePoint","velocity","getVelocity","length","timeDelta","i","timestampedPoint","lastPoint","time","currentVelocity","Infinity","element","parentNode","Array","from","children","indexOf"],"sources":["C:/Users/Sudeep Solapure/Desktop/newswan/node_modules/framer-motion/dist/es/gestures/pan/PanSession.mjs"],"sourcesContent":["import { capturePointer, isPrimaryPointer } from 'motion-dom';\nimport { secondsToMilliseconds, millisecondsToSeconds } from 'motion-utils';\nimport { addPointerEvent } from '../../events/add-pointer-event.mjs';\nimport { extractEventInfo } from '../../events/event-info.mjs';\nimport { distance2D } from '../../utils/distance.mjs';\nimport { pipe } from '../../utils/pipe.mjs';\nimport { frame, cancelFrame, frameData } from '../../frameloop/frame.mjs';\n\n/**\n * @internal\n */\nclass PanSession {\n    constructor(event, handlers, { transformPagePoint, dragSnapToOrigin = false } = {}) {\n        /**\n         * @internal\n         */\n        this.startEvent = null;\n        /**\n         * @internal\n         */\n        this.lastMoveEvent = null;\n        /**\n         * @internal\n         */\n        this.lastMoveEventInfo = null;\n        /**\n         * @internal\n         */\n        this.handlers = {};\n        this.updatePoint = () => {\n            if (!(this.lastMoveEvent && this.lastMoveEventInfo))\n                return;\n            const info = getPanInfo(this.lastMoveEventInfo, this.history);\n            const isPanStarted = this.startEvent !== null;\n            // Only start panning if the offset is larger than 3 pixels. If we make it\n            // any larger than this we'll want to reset the pointer history\n            // on the first update to avoid visual snapping to the cursoe.\n            const isDistancePastThreshold = distance2D(info.offset, { x: 0, y: 0 }) >= 3;\n            if (!isPanStarted && !isDistancePastThreshold)\n                return;\n            const { point } = info;\n            const { timestamp } = frameData;\n            this.history.push({ ...point, timestamp });\n            const { onStart, onMove } = this.handlers;\n            if (!isPanStarted) {\n                onStart && onStart(this.lastMoveEvent, info);\n                this.startEvent = this.lastMoveEvent;\n            }\n            onMove && onMove(this.lastMoveEvent, info);\n        };\n        this.handlePointerMove = (event, info) => {\n            this.index = getElementIndex(event.currentTarget);\n            if (event.target instanceof Element &&\n                event.target.hasPointerCapture &&\n                event.pointerId !== undefined) {\n                try {\n                    if (!event.target.hasPointerCapture(event.pointerId)) {\n                        return;\n                    }\n                }\n                catch (e) { }\n            }\n            this.lastMoveEvent = event;\n            this.lastMoveEventInfo = transformPoint(info, this.transformPagePoint);\n            // Throttle mouse move event to once per frame\n            frame.update(this.updatePoint, true);\n        };\n        this.handlePointerUp = (event, info) => {\n            capturePointer(event, \"release\");\n            this.end();\n            const { onEnd, onSessionEnd, resumeAnimation } = this.handlers;\n            if (this.dragSnapToOrigin)\n                resumeAnimation && resumeAnimation();\n            if (!(this.lastMoveEvent && this.lastMoveEventInfo))\n                return;\n            const panInfo = getPanInfo(event.type === \"pointercancel\" ||\n                event.type === \"lostpointercapture\"\n                ? this.lastMoveEventInfo\n                : transformPoint(info, this.transformPagePoint), this.history);\n            if (this.startEvent && onEnd) {\n                onEnd(event, panInfo);\n            }\n            onSessionEnd && onSessionEnd(event, panInfo);\n        };\n        // If we have more than one touch, don't start detecting this gesture\n        if (!isPrimaryPointer(event))\n            return;\n        this.dragSnapToOrigin = dragSnapToOrigin;\n        this.handlers = handlers;\n        this.transformPagePoint = transformPagePoint;\n        const info = extractEventInfo(event);\n        const initialInfo = transformPoint(info, this.transformPagePoint);\n        const { point } = initialInfo;\n        const { timestamp } = frameData;\n        this.history = [{ ...point, timestamp }];\n        const { onSessionStart } = handlers;\n        onSessionStart &&\n            onSessionStart(event, getPanInfo(initialInfo, this.history));\n        capturePointer(event, \"set\");\n        this.removeListeners = pipe(addPointerEvent(event.currentTarget, \"pointermove\", this.handlePointerMove), addPointerEvent(event.currentTarget, \"pointerup\", this.handlePointerUp), addPointerEvent(event.currentTarget, \"pointercancel\", this.handlePointerUp), addPointerEvent(event.currentTarget, \"lostpointercapture\", (lostPointerEvent, lostPointerInfo) => {\n            const index = getElementIndex(lostPointerEvent.currentTarget);\n            /**\n             * If the pointer has lost capture because it's moved in the DOM\n             * then we need to re-capture it.\n             */\n            if (index !== this.index) {\n                capturePointer(lostPointerEvent, \"set\");\n            }\n            else {\n                this.handlePointerUp(lostPointerEvent, lostPointerInfo);\n            }\n        }));\n    }\n    updateHandlers(handlers) {\n        this.handlers = handlers;\n    }\n    end() {\n        this.removeListeners && this.removeListeners();\n        cancelFrame(this.updatePoint);\n    }\n}\nfunction transformPoint(info, transformPagePoint) {\n    return transformPagePoint ? { point: transformPagePoint(info.point) } : info;\n}\nfunction subtractPoint(a, b) {\n    return { x: a.x - b.x, y: a.y - b.y };\n}\nfunction getPanInfo({ point }, history) {\n    return {\n        point,\n        delta: subtractPoint(point, lastDevicePoint(history)),\n        offset: subtractPoint(point, startDevicePoint(history)),\n        velocity: getVelocity(history, 0.1),\n    };\n}\nfunction startDevicePoint(history) {\n    return history[0];\n}\nfunction lastDevicePoint(history) {\n    return history[history.length - 1];\n}\nfunction getVelocity(history, timeDelta) {\n    if (history.length < 2) {\n        return { x: 0, y: 0 };\n    }\n    let i = history.length - 1;\n    let timestampedPoint = null;\n    const lastPoint = lastDevicePoint(history);\n    while (i >= 0) {\n        timestampedPoint = history[i];\n        if (lastPoint.timestamp - timestampedPoint.timestamp >\n            secondsToMilliseconds(timeDelta)) {\n            break;\n        }\n        i--;\n    }\n    if (!timestampedPoint) {\n        return { x: 0, y: 0 };\n    }\n    const time = millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp);\n    if (time === 0) {\n        return { x: 0, y: 0 };\n    }\n    const currentVelocity = {\n        x: (lastPoint.x - timestampedPoint.x) / time,\n        y: (lastPoint.y - timestampedPoint.y) / time,\n    };\n    if (currentVelocity.x === Infinity) {\n        currentVelocity.x = 0;\n    }\n    if (currentVelocity.y === Infinity) {\n        currentVelocity.y = 0;\n    }\n    return currentVelocity;\n}\nfunction getElementIndex(element) {\n    if (!element.parentNode)\n        return -1;\n    return Array.from(element.parentNode.children).indexOf(element);\n}\n\nexport { PanSession };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}